package com.mparticle.api

import kotlinx.cinterop.addressOf
import kotlinx.cinterop.allocArrayOf
import kotlinx.cinterop.memScoped
import kotlinx.cinterop.usePinned
import platform.Foundation.NSData
import platform.Foundation.create
import platform.posix.memcpy
import kotlin.reflect.KMutableProperty0
import kotlin.reflect.KProperty

/**
 * The iOS wrapper generated by mutiplatform has a weird quirk in it where, for every property, it
 * will also generate a setter and getter method with the same name. for example, Class Foo might look
 * like:
 *
 * class Foo {
 *      var bar: String
 *      fun bar(): String
 *      fun setBar(bar: String)
 * }
 *
 * This makes it impossible to use the `bar` or `bar()` as a delegate, since there is ambiguity
 * when referencing it.
 *
 * for example if you wanted to use Foo.bar to delegate Fuzz.baz, as such:
 *
 * class Fuzz(foo: Foo) {
 *      var baz: String by foo::bar
 * }
 *
 * it will fail as ambiguous.
 *
 * This helper function will indicate to the compiler that you are referencing the *property* `foo`.
 * Using this method, you get the above to work by:
 *
 * class Fuzz(foo: Foo) {
 *      var baz: String by property(foo::bar)
 * }
 */
fun <T> property(property: KMutableProperty0<T>): KMutableProperty0<T> = property


/**
 * helper used for delegating to a "transformable" type. This can be used when we have a Kotlin field
 * of type String that we want to delegate to a generated iOS field that has type NSString. Assuming
 * we have the mapping methods, we can use it as such:
 *
 * //iOS generated class
 * class Foo {
 *      var bar: NSString
 * }
 *
 * //delegated kotlin class
 * class Fuzz(foo: Foo) {
 *      fun String.toNSString(): NSString
 *      fun NSString.toKString(): String
 *
 *      var baz: String by TransformDelegate(foo::bar, { toNSString() }, { toKString() }
 * }
 *
 */
class  TransformDelegate<T, R>(private val property: KMutableProperty0<R>, private val transformer: Transformer<T, R>) {
    operator fun getValue(ref: Any?, kProp: KProperty<*>): T {
        return property.getValue(ref, kProp).let { transformer .to(it) }
    }

    operator fun setValue(ref: Any?, kProp: KProperty<*>, value: T) {
        transformer.from(value).let {
            property.setValue(ref, kProp, it)
        }
    }
}

interface Transformer<T, R> {
    fun from(target: T): R
    fun to(target: R): T
}

//fun <T, R> TransformerOf(to: T.() -> R, from: R.() -> T) =

object TransformBuilder {
    fun <T, R> from(fromFunction: T.() -> R): TransformFrom<T, R> = fromFunction
}

//typealias TransformFrom<T, R> = R.() -> T
typealias TransformFrom<T, R> = T.() -> R
fun <T, R> TransformFrom<T, R>.to(toFunction: R.() -> T): Transformer<T, R> =
    object: Transformer<T, R> {
        override fun from(target: T): R = this@to.invoke(target)
        override fun to(target: R): T = target.toFunction()
    }

//EXAMPLE
private val stringIntTransformer: Transformer<String, Int> = TransformBuilder
    .from<String, Int> { this.toInt() }
    .to {this.toString()}











fun ByteArray.toNSData() : NSData = memScoped {
    NSData.create(bytes = allocArrayOf(this@toNSData),
        length = this@toNSData.size.toULong())
}

fun NSData.toByteArray(): ByteArray = ByteArray(this@toByteArray.length.toInt()).apply {
    usePinned {
        memcpy(it.addressOf(0), this@toByteArray.bytes, this@toByteArray.length)
    }
}